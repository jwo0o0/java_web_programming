# 1주차 - 자바 개요 및 객체지향 프로그래밍

## 자바(Java)

---

### 자바의 특징

- 객체지향 프로그래밍
- 함수적 스타일 코딩 지원
- 자동 메모리 관리
- 다양한 애플리케이션 지원
- 멀티스레딩 지원
- 동적 로딩 지원
- 막강한 오픈소스 라이브러리 지원

### 자바 프로그래밍 과정

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3a563914-8b66-4f1f-bc57-522402c32e2d/Untitled.png)

1. java 소스 파일 작성
2. 컴파일러가 바이트 코드 파일(.class) 생성
3. JVM이 실행

### 1. JSP(Java Server Page)

> HTML 내에 자바 코드를 삽입해 웹 서버에서 동적으로 웹 페이지를 생성해 웹 브라우저에 돌려주는 서버 사이드 스크립트 언어
> 
- 실행시 자바 서블릿으로 변환됨

### 2. 자바 서블릿

> 자바를 사용해 웹 페이지를 동적으로 생성하는 서버측 프로그램
> 
- 자바 클래스의 일종, 웹 서버의 성능 향상을 위해 사용
- JSP와 차이점
    - **JSP**: HTML 문서 안에 java 코드를 포함
    - **서블릿**: java 코드 안에 HTML을 포함

### 3. 스프링 프레임워크

> 자바 플랫픔을 위한 오픈 소스 애플리케이션 프레임워크
> 
- **특징**
    1. 경량 컨테이너로서 자바 객체를 직접 관리
    2. 제어 반전(IoC)를 지원
    3. 의존성 주입(DI) 지원
    4. 관점 지향 프로그래밍(AOP)
    5. 영속성 관련 다양한 서비스 지원
    6. 확장성 높음

## 객체지향 프로그래밍

---

> 부품 객체를 먼저 만들고 이것들을 하나씩 조립해 완성된 프로그램을 만드는 기법
> 

### 객체

- 물리적으로 존재한 것
- **필드**(속성)과 **메소드**(동작)으로 구성된 자바 객체로 모델링 가능
- 객체들은 서로 간에 기능(동작)을 이용하고 데이터를 주고 받음

### 객체간의 관계

객체는 다른 객체와 관계를 맺음

- 집합 관계, 사용 관계, 상속 관계

### 1. 캡슐화

> 객체의 필드, 메소드를 하나로 묶고, **실제 구현 내용을 감추는 것**
> 
- 외부 객체: 객체 내부 구조를 알지 못함
    
    → 객체가 손상되지 않도록 보호
    
    → 접근 제한자를 통해 캡슐화된 멤버의 노출 여부를 결정
    

### 2. 상속

> 상위(부모) 객체의 필드와 메소드를 하위(자식) 객체에게 물려주는 행위
> 
- 상속 대상: 필드와 메소드
- **효과**
    
    → 상위 객체를 재사용
    
    → 중복을 줄임
    
    → 유지보수의 편리성
    
    → 객체의 다형성 구현
    

### 3. 다형성(polymorphism)

> 같은 타입이지만 이를 따르는 다양한 객체를 대입할 수 있는 성질
> 
- 부모 타입 - 모든 자식 객체 대입
- 인터페이스 - 모든 구현 객체 대입
- **효과**
    
    → 객체를 부품화
    
    → 유지보수 용이
    

## 클래스

---

> 객체를 생성하기 위한 틀, 청사진
> 
- 멤버 변수 + 메소드로 구성
- **인스턴스**: 클래스로 규정된 형태를 실체화 한 것

### 객체 생성

- `new` 연산자
- 힙 메모리 영역에 생성

### 클래스의 용도

1. 라이브러리용
2. 실행용 - `main()` 메소드 포함

### 멤버 변수

- 접근 제한자
    - `public`, `private`, `protected`
- 정적 멤버 변수 - 앞에 `static`

## 메소드

---

- 객체의 동작(기능)
- 호출해서 실행할 수 있는 중괄호 블록 {}

```java
리턴타입 메소드이름 ([매개변수 선언, ...]) {
	...
	실행 코드
	...
}
```

- **리턴 타입** - 있을 수도 없을 수도
- **매개변수 선언** - 있을 수도 없을 수도

### 메소드에서 값의 반환(return)

메소드 실행을 중지하고 리턴값을 지정하는 역할

1) 리턴값이 있는 메소드

- 반드시 return 문 사용해서 리턴값 지정

2) 리턴값이 없는 메소드

- 메소드 실행을 강제 종료 시키는 역할

### 메소드 오버로딩(overloading)

클래스 내에 같은 이름의 메소드를 여러 개 선언한는 것

- 오버로딩 조건: **매개변수의 타입, 개수, 순서**가 달라야 함

### 인스턴스 멤버

객체(인스턴스)마다 가지고 있는 필드와 메소드

- 인스턴스 멤버는 객체에 소속된 멤버이기 때문에 객체가 없이 사용 불가

### this - 객체 자신 지시자

- 인스턴스 자신의 참조를 가지고 있는 키워드

## 정적(static) 멤버

---

클래스에 고정된 필드와 메소드 - 정적 필드, 정적 메소드

**클래스에 소속된 멤버**

- 객체 내부에 존재하지 않고 메소드 영역에 존재
- 객체를 생성하지 않고 클래스로 바로 접근해 사용

### 정적 멤버의 사용

- 클래스 이름과 함께 . 연산자로 접근

### 정적 멤버 초기화

- 인스턴스 - 생성자와 함께 초기화
- 정적 블록 - 안에서 인스턴스 변수나 메소드를 사용할 수 없음

### 인스턴스 멤버 vs. 정적 멤버

**필드**

- 객체마다 가지고 있어야 할 데이터 → 인스턴스 필드
- 공용적인 데이터 → 정적 필드

**메소드**

- 인스턴스 필드로 작업해야 할 메소드 → 인스턴스 메소드
- 인스턴스 필드로 작업하지 않는 메소드 → 정적 메소드

## 클래스의 상속

---

### 상속(inheritance)

> **기존의 클래스를 그대로 물려받으면서 + 필요한 필드나 메소드를 추가로 정의**
> 

### 추상 클래스와 추상 메소드

**추상 클래스**

- 인스턴스화를 금지하는 클래스
- `abstract` 키워드

**추상 메소드**

- 메소드 본체가 없는 메소드
- 메소드 앞에 abstract
- **추상 메소드를 포함하는 클래스는 추상 클래스로 지정해야 함**

### 다형성

> 자신의 서브클래스에서 생성한 인스턴스도 클래스 변수에 대입할 수 있는 것
> 

### 인터페이스

- `interface` 키워드
- 내부에는 추상 메소드
- 클래스에서 인터페이스를 받아서 완성할 때 `implements` 키워드
- java - 다중 상속 지원 x, 인터페이스를 이용해 비슷하게 작성할 수 있음

### 익명 내부 클래스(anonymous inner class)

- 한번만 사용하고 버려지는 클래스에 사용

## 접근 제한자(access modifier)

---

> 클래스 및 클래스의 구성 멤버에 대한 접근을 제한하는 역할
> 

**private < defaut < protected < public** 

- 클래스 제한 - 다른 패키지에서 클래스를 사용하지 못하도록
- 생성자 제한 - 클래스로부터 객체를 생성하지 못하도록
- 필드와 메소드 제한 - 특정 메소드를 숨김 처리

### Getter 와 Setter

클래스 선언시 필드는 일반적으로 private

→ Getter로 읽기전용 필드

→ Setter로 외부에서 엉뚱한 값으로 변경할 수 없도록

## 패키지

---

> 클래스를 기능별로 묶어서 그룹 이름을 붙여놓은 것
> 
- 물리적인 형태는 파일 시스템의 폴더

**클래스 이름의 일부**

- 클래스를 유일하게 만들어주는 식별자
- 전체 클래스 이름 = 상위 패키지.하위패키지.클래스
- 클래스 명이 같아도 패키지 명이 다르면 다른 클래스임

### 클래스 선언시 패키지 결정

클래스 파일은 선언된 패키지와 동일한 폴더 안에서만 동작

### import 문

1) 패키지 내에 같이 포함된 클래스간 클래스 이름으로 사용 가능

2) 패키지가 다른 클래스를 사용해야 할 경우

- 패키지 명 포함된 전체 클래스 이름으로 사용
- import문으로 패키지를 지정하고 사용